<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Block Dash - Play & Level Editor</title>
<style>
  body {
    margin: 0; 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    background: #222;
    color: white;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    display: flex;
    justify-content: center;
    background: #111;
    padding: 10px 0;
    border-bottom: 2px solid #444;
  }
  button.tab-btn {
    background: #333;
    border: none;
    color: white;
    padding: 10px 25px;
    margin: 0 5px;
    font-size: 1rem;
    border-radius: 5px 5px 0 0;
    cursor: pointer;
    transition: background 0.3s;
  }
  button.tab-btn.active {
    background: #4e54c8;
  }
  main {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 15px;
    background: #1e1e1e;
  }
  #level-select, #editor-level-list {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 15px;
  }
  .level-button, .editor-level-button {
    background: #555;
    border-radius: 8px;
    padding: 8px 14px;
    font-weight: bold;
    font-size: 1rem;
    cursor: pointer;
    color: white;
    border: 2px solid transparent;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .level-button.locked, .editor-level-button.locked {
    background: #444;
    color: #888;
    cursor: default;
  }
  .level-button.selected, .editor-level-button.selected {
    border-color: #fff;
    background: #777;
  }
  #play-button, #save-level-btn, #new-level-btn {
    margin-top: 10px;
    background: #4e54c8;
    border: none;
    border-radius: 8px;
    color: white;
    padding: 10px 22px;
    font-size: 1.1rem;
    cursor: pointer;
    transition: background 0.3s;
  }
  #play-button:hover, #save-level-btn:hover, #new-level-btn:hover {
    background: #3b3fc1;
  }
  #progress {
    margin-top: 6px;
    font-family: Consolas, monospace;
    font-size: 18px;
  }
  #game-container {
    position: relative;
    width: 600px;
    height: 300px;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 30px #0009 inset;
    background: #222;
  }
  canvas {
    display: block;
    border-radius: 12px;
    background: linear-gradient(to bottom, #6dd5fa, #2980b9);
    cursor: pointer;
  }

  /* Editor styles */
  #editor {
    width: 620px;
    max-width: 100%;
    background: #333;
    padding: 10px 12px;
    border-radius: 12px;
    box-sizing: border-box;
  }
  #editor-label {
    margin-bottom: 6px;
    font-size: 1.2rem;
  }
  #level-name-input {
    width: 100%;
    font-size: 1.1rem;
    padding: 6px 10px;
    border-radius: 6px;
    border: none;
    margin-bottom: 10px;
    box-sizing: border-box;
  }
  #spike-types {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
  }
  .spike-type-btn {
    background: #4e54c8;
    border-radius: 8px;
    padding: 8px 12px;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    transition: background 0.3s;
  }
  .spike-type-btn.selected {
    background: #3b3fc1;
  }
  #timeline {
    width: 100%;
    height: 60px;
    background: #222;
    border-radius: 8px;
    position: relative;
    user-select: none;
    overflow-x: scroll;
    white-space: nowrap;
    box-sizing: border-box;
    padding: 5px 0;
  }
  .timeline-segment {
    display: inline-block;
    width: 25px;
    height: 60px;
    margin: 0 1px;
    background: #555;
    border-radius: 4px;
    position: relative;
    cursor: pointer;
  }
  .timeline-segment.selected {
    background: #4e54c8;
  }
  .timeline-spikes {
    position: absolute;
    bottom: 4px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 3px;
  }
  .timeline-spike {
    width: 18px;
    height: 18px;
    clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
    background: #ff3b3b;
  }

  /* Scrollbar for timeline */
  #timeline::-webkit-scrollbar {
    height: 8px;
  }
  #timeline::-webkit-scrollbar-thumb {
    background: #666;
    border-radius: 4px;
  }

  /* Checkbox for completed */
  .completed-check {
    color: #0f0;
    font-weight: bold;
  }

  /* Responsive tweaks */
  @media (max-width: 650px) {
    #game-container, #editor {
      width: 100%;
    }
    canvas {
      width: 100%;
      height: auto;
    }
  }
</style>
</head>
<body>

<header>
  <button id="tab-play" class="tab-btn active">Play Levels</button>
  <button id="tab-editor" class="tab-btn">Level Editor</button>
</header>

<main>
  <!-- Play Tab -->
  <section id="play-tab">
    <div id="level-select"></div>
    <button id="play-button" disabled>Play</button>
    <div id="progress">Progress: 0%</div>
    <div id="game-container">
      <canvas id="game" width="600" height="300" tabindex="0" title="Click or tap to jump"></canvas>
    </div>
  </section>

  <!-- Editor Tab -->
  <section id="editor-tab" style="display:none;">
    <button id="new-level-btn">New Level</button>
    <div id="editor-level-list" style="margin: 10px 0;"></div>
    <div id="editor" style="display:none;">
      <label id="editor-label" for="level-name-input">Level Name:</label>
      <input type="text" id="level-name-input" placeholder="Enter level name" />
      <div id="spike-types">
        <div class="spike-type-btn" data-count="1">1 Spike</div>
        <div class="spike-type-btn" data-count="2">2 Spikes</div>
        <div class="spike-type-btn" data-count="3">3 Spikes</div>
        <div class="spike-type-btn" data-count="4">4 Spikes</div>
      </div>
      <div id="timeline"></div>
      <button id="save-level-btn" disabled>Save Level</button>
    </div>
  </section>
</main>

<audio id="bg-music" loop>
  <source src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_4d9f4d61ec.mp3?filename=game-music-loop-6294.mp3" type="audio/mpeg">
</audio>

<script>
(() => {
  // DOM references
  const tabPlay = document.getElementById('tab-play');
  const tabEditor = document.getElementById('tab-editor');
  const playTab = document.getElementById('play-tab');
  const editorTab = document.getElementById('editor-tab');
  const levelSelectDiv = document.getElementById('level-select');
  const playBtn = document.getElementById('play-button');
  const progressDisplay = document.getElementById('progress');
  const gameContainer = document.getElementById('game-container');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const bgMusic = document.getElementById('bg-music');

  // Editor DOM
  const newLevelBtn = document.getElementById('new-level-btn');
  const editorLevelList = document.getElementById('editor-level-list');
  const editorDiv = document.getElementById('editor');
  const levelNameInput = document.getElementById('level-name-input');
  const spikeTypeButtons = Array.from(document.querySelectorAll('.spike-type-btn'));
  const timelineDiv = document.getElementById('timeline');
  const saveLevelBtn = document.getElementById('save-level-btn');

  // Constants & variables
  const width = canvas.width;
  const height = canvas.height;

  const levelDuration = 30000; // 30 seconds fixed level length
  const spikeWidth = 25;
  const spikeHeight = 25;

  let gameRunning = false;
  let gameOver = false;
  let gameWin = false;
  let startTime = 0;

  // Player setup on the ground exactly aligned with spikes
  const player = {
    x: 80,
    y: height - 40 - 30, // ground height 40 + player height 30, so y = ground top - player height
    width: 30,
    height: 30,
    color: '#ffd700',
    vy: 0,
    gravity: 0.8,
    jumpPower: -14,
    onGround: true,
    baseY: height - 40 - 30,
  };

  let spikeSpeed = 6;
  let spikes = [];

  // Level data structure
  // Levels saved in localStorage as array of objects:
  // { id, name, spikes: [{pos: number (px), count: 1-4}] }

  let levels = [];
  let beatenLevels = new Set();
  let currentLevelIndex = 0;
  let selectedLevel = null;

  // Tabs switching
  tabPlay.addEventListener('click', () => {
    if (gameRunning) return; // block switching mid game
    tabPlay.classList.add('active');
    tabEditor.classList.remove('active');
    playTab.style.display = 'block';
    editorTab.style.display = 'none';
  });
  tabEditor.addEventListener('click', () => {
    if (gameRunning) return;
    tabPlay.classList.remove('active');
    tabEditor.classList.add('active');
    playTab.style.display = 'none';
    editorTab.style.display = 'block';
  });

  // Storage keys
  const STORAGE_LEVELS_KEY = 'blockDash_levels';
  const STORAGE_BEATEN_KEY = 'blockDash_beaten';

  // Save/load
  function loadLevels() {
    const raw = localStorage.getItem(STORAGE_LEVELS_KEY);
    if (raw) {
      try {
        levels = JSON.parse(raw);
      } catch {
        levels = [];
      }
    }
    if (!Array.isArray(levels)) levels = [];
  }
  function saveLevels() {
    localStorage.setItem(STORAGE_LEVELS_KEY, JSON.stringify(levels));
  }
  function loadBeaten() {
    const raw = localStorage.getItem(STORAGE_BEATEN_KEY);
    if (raw) {
      try {
        beatenLevels = new Set(JSON.parse(raw));
      } catch {
        beatenLevels = new Set();
      }
    }
  }
  function saveBeaten() {
    localStorage.setItem(STORAGE_BEATEN_KEY, JSON.stringify(Array.from(beatenLevels)));
  }

  // UI renderers
  function renderLevelSelect() {
    levelSelectDiv.innerHTML = '';
    levels.forEach((level, i) => {
      const btn = document.createElement('button');
      btn.classList.add('level-button');
      btn.textContent = level.name;
      if (beatenLevels.has(level.id)) {
        btn.textContent += ' ✅';
      }
      if (i === currentLevelIndex) {
        btn.classList.add('selected');
      }
      btn.disabled = gameRunning; // disable if playing
      btn.addEventListener('click', () => {
        if (gameRunning) return;
        currentLevelIndex = i;
        selectedLevel = levels[currentLevelIndex];
        updateLevelButtons();
        playBtn.disabled = false;
        progressDisplay.textContent = 'Progress: 0%';
      });
      levelSelectDiv.appendChild(btn);
    });
  }
  function updateLevelButtons() {
    const buttons = levelSelectDiv.querySelectorAll('button');
    buttons.forEach((btn, i) => {
      btn.classList.toggle('selected', i === currentLevelIndex);
    });
  }

  // Editor UI render
  let editorSelectedLevelIndex = -1;
  function renderEditorLevelList() {
    editorLevelList.innerHTML = '';
    levels.forEach((level, i) => {
      const btn = document.createElement('button');
      btn.classList.add('editor-level-button');
      btn.textContent = level.name;
      if (beatenLevels.has(level.id)) {
        btn.textContent += ' ✅';
      }
      if (i === editorSelectedLevelIndex) {
        btn.classList.add('selected');
      }
      btn.addEventListener('click', () => {
        editorSelectedLevelIndex = i;
        loadLevelInEditor(levels[i]);
        renderEditorLevelList();
      });
      editorLevelList.appendChild(btn);
    });
  }

  // Editor spike selection
  let selectedSpikeCount = 1; // default 1 spike

  spikeTypeButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      spikeTypeButtons.forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      selectedSpikeCount = parseInt(btn.dataset.count);
    });
  });
  // Default select first spike count button
  spikeTypeButtons[0].classList.add('selected');

  // Timeline for spike placement
  // timeline length is fixed to 30 seconds, divided into segments (1 segment = 200px)
  const timelineLengthPx = 10800; // same as game distance for level
  const timelineSegments = 10800 / 25; // segments of 25px width (equals 432 segments)
  // We'll show timeline scrollable with those segments

  let timelineSegmentsData = new Array(timelineSegments).fill(0); // 0 means no spikes, else number of spikes

  function renderTimeline() {
    timelineDiv.innerHTML = '';
    for (let i = 0; i < timelineSegments; i++) {
      const seg = document.createElement('div');
      seg.classList.add('timeline-segment');
      if (timelineSegmentsData[i] > 0) seg.classList.add('selected');
      seg.dataset.index = i;

      // Draw spikes inside segment
      if (timelineSegmentsData[i] > 0) {
        const spikeContainer = document.createElement('div');
        spikeContainer.classList.add('timeline-spikes');
        for (let s = 0; s < timelineSegmentsData[i]; s++) {
          const spike = document.createElement('div');
          spike.classList.add('timeline-spike');
          spikeContainer.appendChild(spike);
        }
        seg.appendChild(spikeContainer);
      }

      seg.addEventListener('click', () => {
        // Set spike count for this segment to selectedSpikeCount or clear if already that count
        if (timelineSegmentsData[i] === selectedSpikeCount) {
          timelineSegmentsData[i] = 0;
        } else {
          timelineSegmentsData[i] = selectedSpikeCount;
        }
        renderTimeline();
      });

      timelineDiv.appendChild(seg);
    }
  }

  // Load a level into the editor
  function loadLevelInEditor(level) {
    editorDiv.style.display = 'block';
    levelNameInput.value = level.name;
    // Reset timeline segments
    timelineSegmentsData = new Array(timelineSegments).fill(0);
    // Set spikes from level data
    for (const sp of level.spikes) {
      // Each spike group position is in px, convert to segment index
      const idx = Math.floor(sp.pos / 25);
      if (idx >= 0 && idx < timelineSegments) {
        timelineSegmentsData[idx] = sp.count;
      }
    }
    renderTimeline();
    saveLevelBtn.disabled = false;
  }

  // Create new level template
  function createNewLevel() {
    editorDiv.style.display = 'block';
    levelNameInput.value = '';
    timelineSegmentsData = new Array(timelineSegments).fill(0);
    renderTimeline();
    editorSelectedLevelIndex = -1;
    saveLevelBtn.disabled = false;
  }

  // Save level from editor input & timeline to levels array and localStorage
  function saveLevelFromEditor() {
    const name = levelNameInput.value.trim();
    if (!name) {
      alert('Please enter a level name!');
      return;
    }

    // Extract spikes from timelineSegmentsData
    const spikesData = [];
    for (let i = 0; i < timelineSegmentsData.length; i++) {
      const count = timelineSegmentsData[i];
      if (count > 0) {
        spikesData.push({ pos: i * 25, count });
      }
    }

    if (spikesData.length === 0) {
      alert('Add some spikes before saving!');
      return;
    }

    if (editorSelectedLevelIndex === -1) {
      // New level
      const newLevel = {
        id: Date.now().toString(),
        name,
        spikes: spikesData,
      };
      levels.push(newLevel);
      editorSelectedLevelIndex = levels.length - 1;
    } else {
      // Update existing level
      levels[editorSelectedLevelIndex].name = name;
      levels[editorSelectedLevelIndex].spikes = spikesData;
    }

    saveLevels();
    renderEditorLevelList();
    renderLevelSelect();
    alert('Level saved!');
  }

  // Initialize game spikes array from selectedLevel data spikes
  function loadSpikesFromLevel(level) {
    spikes = [];
    spikeSpeed = 6 + currentLevelIndex * 2;

    level.spikes.forEach(sp => {
      for (let i = 0; i < sp.count; i++) {
        spikes.push({
          x: 600 + sp.pos + i * (spikeWidth + 2),
          y: height - 40 - spikeHeight,
          width: spikeWidth,
          height: spikeHeight,
        });
      }
    });
  }

  // Reset game state
  function resetGame() {
    if (!selectedLevel) return;
    gameOver = false;
    gameWin = false;
    startTime = performance.now();
    player.y = player.baseY;
    player.vy = 0;
    player.onGround = true;

    loadSpikesFromLevel(selectedLevel);
    progressDisplay.textContent = 'Progress: 0%';

    bgMusic.pause();
    bgMusic.currentTime = 0;
    bgMusic.play().catch(() => {});

    playBtn.disabled = true;
  }

  // Draw spike shape
  function drawSpike(x, y, w, h) {
    ctx.fillStyle = '#ff3b3b';
    ctx.beginPath();
    ctx.moveTo(x, y + h);        // bottom left
    ctx.lineTo(x + w / 2, y);    // top center (spike tip)
    ctx.lineTo(x + w, y + h);    // bottom right
    ctx.closePath();
    ctx.fill();
  }

  // Spike collision detection using point-in-triangle for accuracy
  function pointInTriangle(px, py, ax, ay, bx, by, cx, cy) {
    const v0x = cx - ax;
    const v0y = cy - ay;
    const v1x = bx - ax;
    const v1y = by - ay;
    const v2x = px - ax;
    const v2y = py - ay;

    const dot00 = v0x * v0x + v0y * v0y;
    const dot01 = v0x * v1x + v0y * v1y;
    const dot02 = v0x * v2x + v0y * v2y;
    const dot11 = v1x * v1x + v1y * v1y;
    const dot12 = v1x * v2x + v1y * v2y;

    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) return false;

    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    return (u >= 0) && (v >= 0) && (u + v < 1);
  }

  function checkSpikeCollision(spike) {
    const ax = spike.x;
    const ay = spike.y + spike.height;
    const bx = spike.x + spike.width / 2;
    const by = spike.y;
    const cx = spike.x + spike.width;
    const cy = spike.y + spike.height;

    const corners = [
      { x: player.x, y: player.y },
      { x: player.x + player.width, y: player.y },
      { x: player.x, y: player.y + player.height },
      { x: player.x + player.width, y: player.y + player.height }
    ];

    for (const corner of corners) {
      if (pointInTriangle(corner.x, corner.y, ax, ay, bx, by, cx, cy)) {
        return true;
      }
    }

    // Also check spike tip inside player box
    if (bx >= player.x && bx <= player.x + player.width &&
        by >= player.y && by <= player.y + player.height) {
      return true;
    }

    return false;
  }

  // Game loop
  function gameLoop(timestamp) {
    if (!gameRunning) return;

    ctx.clearRect(0, 0, width, height);

    // Background gradient per level
    const bgColors = {
      blue: ['#6dd5fa', '#2980b9'],
      green: ['#56ab2f', '#a8e063'],
      red: ['#cb2d3e', '#ef473a'],
    };

    // Choose background by level index cycling colors
    let bg;
    switch (currentLevelIndex) {
      case 0: bg = bgColors.blue; break;
      case 1: bg = bgColors.green; break;
      case 2: bg = bgColors.red; break;
      default: bg = bgColors.blue;
    }
    const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
    bgGradient.addColorStop(0, bg[0]);
    bgGradient.addColorStop(1, bg[1]);
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, width, height);

    // Ground
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, height - 40, width, 40);

    // Player physics
    player.vy += player.gravity;
    player.y += player.vy;

    if (player.y > player.baseY) {
      player.y = player.baseY;
      player.vy = 0;
      player.onGround = true;
    }

    // Draw player block
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // Move and draw spikes + collision check
    for (const spike of spikes) {
      spike.x -= spikeSpeed;
      drawSpike(spike.x, spike.y, spike.width, spike.height);

      if (checkSpikeCollision(spike)) {
        gameOver = true;
      }
    }

    // Progress display
    const elapsed = timestamp - startTime;
    const progressPercent = Math.min(100, (elapsed / levelDuration) * 100);
    progressDisplay.textContent = `Progress: ${progressPercent.toFixed(1)}%`;

    if (gameOver) {
      bgMusic.pause();

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = 'white';
      ctx.font = '36px Arial Black, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', width / 2, height / 2 - 20);
      ctx.font = '20px Arial';
      ctx.fillText('Click Play to try again', width / 2, height / 2 + 20);

      gameRunning = false;
      playBtn.disabled = false;
      return;
    }

    if (elapsed >= levelDuration) {
      bgMusic.pause();

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = 'white';
      ctx.font = '36px Arial Black, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Level Complete!', width / 2, height / 2 - 20);
      ctx.font = '20px Arial';
      ctx.fillText('Click Play to play again', width / 2, height / 2 + 20);

      // Mark beaten level
      beatenLevels.add(selectedLevel.id);
      saveBeaten();
      renderLevelSelect();
      renderEditorLevelList();

      gameRunning = false;
      playBtn.disabled = false;
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  // Jump action
  function jump() {
    if (!gameRunning) return;
    if (player.onGround) {
      player.vy = player.jumpPower;
      player.onGround = false;
    }
  }

  // Input listeners
  canvas.addEventListener('mousedown', jump);
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    jump();
  }, { passive: false });
  window.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      jump();
    }
  });

  // Play button click
  playBtn.addEventListener('click', () => {
    if (!selectedLevel) return;
    resetGame();
    gameRunning = true;
    playBtn.disabled = true;
    requestAnimationFrame(gameLoop);
  });

  // Editor buttons
  newLevelBtn.addEventListener('click', () => {
    createNewLevel();
  });
  saveLevelBtn.addEventListener('click', () => {
    saveLevelFromEditor();
  });

  // Initial load
  loadLevels();
  loadBeaten();

  // If no levels, add 3 starter levels for you
  if (levels.length === 0) {
    levels.push(
      {
        id: 'numeroUno',
        name: 'Numero Uno',
        spikes: [
          {pos: 500, count: 1},
          {pos: 1000, count: 2},
          {pos: 1700, count: 1},
          {pos: 2200, count: 2}
        ]
      },
      {
        id: 'dive',
        name: 'Dive',
        spikes: [
          {pos: 400, count: 1},
          {pos: 900, count: 3},
          {pos: 1400, count: 2},
          {pos: 2000, count: 3}
        ]
      },
      {
        id: 'blood',
        name: 'Blood',
        spikes: [
          {pos: 300, count: 4},
          {pos: 900, count: 3},
          {pos: 1300, count: 2},
          {pos: 1900, count: 4}
        ]
      }
    );
    saveLevels();
  }

  selectedLevel = levels[0];
  currentLevelIndex = 0;

  renderLevelSelect();
  renderEditorLevelList();

  // Load first level in editor if any
  if (levels.length > 0) {
    editorSelectedLevelIndex = 0;
    loadLevelInEditor(levels[0]);
  }

})();
</script>

</body>
</html>
