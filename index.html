<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Geometry Dash - Numero Uno & Dive</title>
<style>
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    color: white;
  }
  #progressPercent {
    text-align: center;
    font-weight: bold;
    font-size: 20px;
    margin: 8px 0 0 0;
    text-shadow: 1px 1px 6px #000a;
    user-select: none;
  }
  #message {
    text-align: center;
    font-weight: bold;
    font-size: 18px;
    margin: 6px 0 12px 0;
    text-shadow: 1px 1px 4px #000a;
    user-select: none;
  }
  #levelSelect {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin: 12px 0 6px 0;
  }
  .levelBtn {
    padding: 8px 16px;
    border-radius: 8px;
    border: none;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    background: #50e3c2;
    color: #222;
    position: relative;
  }
  .levelBtn.selected {
    background: #0b796e;
    color: #fff;
  }
  .levelBtn .checkmark {
    position: absolute;
    top: 4px;
    right: 6px;
    font-size: 18px;
    color: greenyellow;
  }
  #gameCanvas {
    border-radius: 10px;
    width: 100%;
    max-height: 220px;
    display: block;
    margin: 0 auto 12px auto;
    touch-action: manipulation;
    background: #004ea8; /* Blue default */
  }
  #controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 12px;
  }
  button#playBtn, button#resetBtn {
    padding: 8px 14px;
    border-radius: 6px;
    border: none;
    background: #50e3c2;
    color: #222;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
  }
  button#resetBtn {
    display: none;
  }
</style>
</head>
<body>

<div id="levelSelect">
  <button class="levelBtn selected" data-level="0" id="btn-numero">Numero Uno</button>
  <button class="levelBtn" data-level="1" id="btn-dive">Dive</button>
</div>

<div id="progressPercent">0% Completed</div>
<div id="message">Tap or click to jump. Avoid the spikes!</div>
<canvas id="gameCanvas" width="600" height="150" aria-label="Game canvas"></canvas>
<div id="controls">
  <button id="playBtn">Play</button>
  <button id="resetBtn">Reset</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const messageEl = document.getElementById('message');
  const progressEl = document.getElementById('progressPercent');
  const playBtn = document.getElementById('playBtn');
  const resetBtn = document.getElementById('resetBtn');
  const levelBtns = document.querySelectorAll('.levelBtn');

  const spikeWidth = 20;
  const spikeHeight = 23;
  const groundY = canvas.height - 40;

  // Levels data: spikes, speed, length, background color, triple spikes allowed?
  const levels = [
    { // Numero Uno
      name: 'Numero Uno',
      speed: 3,
      lengthSec: 20,
      bgColor: '#004ea8', // blue
      allowTriple: false,
      spikes: []
    },
    { // Dive
      name: 'Dive',
      speed: 5,
      lengthSec: 20,
      bgColor: '#267f24', // green
      allowTriple: true,
      spikes: []
    }
  ];

  // Save/load progress to localStorage (completed levels)
  const storageKey = 'gd_numero_dive_progress';
  let completedLevels = JSON.parse(localStorage.getItem(storageKey) || '{}');

  // Build spikes for Numero Uno (no triples, min 120px apart)
  function buildNumeroUnoSpikes() {
    const spikes = [];
    function isSpacingValid(spikes, newTime, newType) {
      const newX = newTime * levels[0].speed * 60;
      for (const spike of spikes) {
        const existingX = spike.time * levels[0].speed * 60;
        const existingWidth = spike.type === 'double' ? spikeWidth * 2 : spikeWidth;
        const newWidth = newType === 'double' ? spikeWidth * 2 : spikeWidth;
        const dist = Math.abs(existingX - newX);
        if (dist < 120) {
          if (!(dist <= existingWidth && (spike.type === 'double' && newType === 'double'))) {
            return false;
          }
        }
      }
      return true;
    }
    let singleCount = 0;
    let time = 2;
    while (singleCount < 15 && time < levels[0].lengthSec - 1) {
      if (isSpacingValid(spikes, time, 'single')) {
        spikes.push({time, type: 'single'});
        singleCount++;
        time += 2; // bigger gap due to 120px spacing
      } else {
        time += 0.1;
      }
    }
    let doubleCount = 0;
    time = 5;
    while (doubleCount < 5 && time < levels[0].lengthSec - 1) {
      if (isSpacingValid(spikes, time, 'double')) {
        spikes.push({time, type: 'double'});
        doubleCount++;
        time += 3;
      } else {
        time += 0.1;
      }
    }
    spikes.sort((a,b) => a.time - b.time);
    return spikes;
  }

  // Build spikes for Dive (triples allowed, min 120px apart, very different layout)
  function buildDiveSpikes() {
    const spikes = [];
    const speed = levels[1].speed;

    function isSpacingValid(spikes, newTime, newType) {
      const newX = newTime * speed * 60;
      for (const spike of spikes) {
        const existingX = spike.time * speed * 60;
        let existingWidth = spike.type === 'triple' ? spikeWidth * 3 : (spike.type === 'double' ? spikeWidth * 2 : spikeWidth);
        let newWidth = newType === 'triple' ? spikeWidth * 3 : (newType === 'double' ? spikeWidth * 2 : spikeWidth);
        const dist = Math.abs(existingX - newX);

        if (dist < 120) {
          if (dist <= existingWidth) {
            if (newType === 'triple' || spike.type === 'triple') return false;
            if (newType === 'double' && spike.type === 'double') return false;
            if ((newType === 'double' && spike.type === 'single') || (newType === 'single' && spike.type === 'double')) return false;
            if (newType === 'single' && spike.type === 'single') return false;
          } else {
            return false;
          }
        }
      }
      return true;
    }

    // Fewer spikes, mix of types, spaced out more widely

    // 8 single spikes
    let singleCount = 0;
    let time = 1.5;
    while (singleCount < 8 && time < levels[1].lengthSec - 1) {
      if (isSpacingValid(spikes, time, 'single')) {
        spikes.push({time, type: 'single'});
        singleCount++;
        time += 2.5;
      } else {
        time += 0.1;
      }
    }

    // 4 double spikes
    let doubleCount = 0;
    time = 6;
    while (doubleCount < 4 && time < levels[1].lengthSec - 1) {
      if (isSpacingValid(spikes, time, 'double')) {
        spikes.push({time, type: 'double'});
        doubleCount++;
        time += 3.5;
      } else {
        time += 0.1;
      }
    }

    // 3 triple spikes
    let tripleCount = 0;
    time = 12;
    while (tripleCount < 3 && time < levels[1].lengthSec - 1) {
      if (isSpacingValid(spikes, time, 'triple')) {
        spikes.push({time, type: 'triple'});
        tripleCount++;
        time += 4;
      } else {
        time += 0.1;
      }
    }

    spikes.sort((a,b) => a.time - b.time);
    return spikes;
  }

  // Initialize spikes for both levels
  levels[0].spikes = buildNumeroUnoSpikes();
  levels[1].spikes = buildDiveSpikes();

  // Player object
  const player = {
    x: 50,
    y: 0,
    width: 30,
    height: 30,
    yVelocity: 0,
    gravity: 0.8,
    jumpStrength: -14,
    grounded: false,
  };

  let currentLevelIndex = 0;
  let frames = 0;
  let maxFrames = 0;
  let gameRunning = false;
  let gameOver = false;
  let win = false;

  // Load/save progress
  const storageKey = 'gd_numero_dive_progress';
  let completedLevels = JSON.parse(localStorage.getItem(storageKey) || '{}');
  function loadProgress() {
    const data = localStorage.getItem(storageKey);
    if (data) {
      completedLevels = JSON.parse(data);
    }
  }
  function saveProgress() {
    localStorage.setItem(storageKey, JSON.stringify(completedLevels));
  }

  // Update level select UI
  function updateLevelButtons() {
    levelBtns.forEach(btn => {
      const idx = parseInt(btn.dataset.level);
      btn.classList.toggle('selected', idx === currentLevelIndex);
      if(completedLevels[idx]) {
        if (!btn.querySelector('.checkmark')) {
          const check = document.createElement('span');
          check.className = 'checkmark';
          check.textContent = 'âœ“';
          btn.appendChild(check);
        }
      } else {
        const existingCheck = btn.querySelector('.checkmark');
        if (existingCheck) existingCheck.remove();
      }
    });
  }

  // Background color
  function updateBackground() {
    canvas.style.background = levels[currentLevelIndex].bgColor;
  }

  // Drawing functions
  function drawGround() {
    ctx.fillStyle = '#333';
    ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
  }

  function drawPlayer() {
    ctx.fillStyle = '#50e3c2';
    ctx.fillRect(player.x, player.y, player.width, player.height);
  }

  function drawSpikeShape(x, y, width, height) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + width/2, y - height);
    ctx.lineTo(x + width, y);
    ctx.closePath();
    ctx.fill();
  }

  function drawSpikes(offsetX) {
    ctx.fillStyle = '#e94e4e';
    const lvl = levels[currentLevelIndex];
    lvl.spikes.forEach(spike => {
      const spikeX = spike.time * lvl.speed * 60;
      let screenX = spikeX - offsetX;
      let widthSpike, countSpikes;
      if(spike.type === 'single') {
        widthSpike = spikeWidth;
        countSpikes = 1;
      } else if(spike.type === 'double') {
        widthSpike = spikeWidth * 2;
        countSpikes = 2;
      } else { // triple
        widthSpike = spikeWidth * 3;
        countSpikes = 3;
      }
      if (screenX + widthSpike > 0 && screenX < canvas.width) {
        for(let i=0; i<countSpikes; i++) {
          drawSpikeShape(screenX + i*spikeWidth, groundY, spikeWidth, spikeHeight);
        }
      }
    });
  }

  function checkCollision(offsetX) {
    const px = player.x;
    const py = player.y;
    const pw = player.width;
    const ph = player.height;
    const lvl = levels[currentLevelIndex];

    for (const spike of lvl.spikes) {
      const spikeX = spike.time * lvl.speed * 60;
      let widthSpike = spikeWidth * (spike.type === 'triple' ? 3 : (spike.type === 'double' ? 2 : 1));
      const spikeY = groundY - spikeHeight;

      if (
        px < spikeX - offsetX + widthSpike &&
        px + pw > spikeX - offsetX &&
        py + ph > spikeY
      ) {
        return true;
      }
    }
    return false;
  }

  function resetGame() {
    frames = 0;
    maxFrames = Math.floor(levels[currentLevelIndex].lengthSec * 60);
    player.y = groundY - player.height;
    player.yVelocity = 0;
    player.grounded = true;
    gameRunning = true;
    gameOver = false;
    win = false;
    messageEl.textContent = '';
    progressEl.textContent = '0% Completed';
    resetBtn.style.display = 'inline-block';
    updateBackground();
  }

  function gameLoop() {
    if (!gameRunning) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let lvl = levels[currentLevelIndex];
    let offsetX = frames * lvl.speed;

    // Player physics
    player.yVelocity += player.gravity;
    player.y += player.yVelocity;

    if (player.y + player.height >= groundY) {
      player.y = groundY - player.height;
      player.yVelocity = 0;
      player.grounded = true;
    } else {
      player.grounded = false;
    }

    drawGround();
    drawSpikes(offsetX);
    drawPlayer();

    // Progress update
    let percent = Math.min(100, Math.floor((frames / maxFrames) * 100));
    progressEl.textContent = percent + '% Completed';

    // Collision detection
    if (checkCollision(offsetX)) {
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = "ðŸ’¥ You hit a spike! Tap Play to try again.";
      resetBtn.style.display = 'none';
      progressEl.textContent = '';
      return;
    }

    frames++;

    if (frames > maxFrames) {
      gameRunning = false;
      win = true;
      messageEl.textContent = "ðŸŽ‰ Level Complete! Tap Play to replay.";
      resetBtn.style.display = 'none';
      progressEl.textContent = '100% Completed';

      // Mark level completed and save progress
      completedLevels[currentLevelIndex] = true;
      saveProgress();
      updateLevelButtons();
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  function jump() {
    if (gameRunning && player.grounded) {
      player.yVelocity = player.jumpStrength;
      player.grounded = false;
    }
  }

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    jump();
  });
  canvas.addEventListener('mousedown', e => {
    e.preventDefault();
    jump();
  });

  playBtn.addEventListener('click', () => {
    resetGame();
    gameLoop();
  });

  resetBtn.addEventListener('click', () => {
    resetGame();
    gameLoop();
    messageEl.textContent = '';
    progressEl.textContent = '0% Completed';
  });

  levelBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      if(gameRunning) return;
      currentLevelIndex = parseInt(btn.dataset.level);
      updateLevelButtons();
      messageEl.textContent = "Tap or click to jump. Avoid the spikes!";
      progressEl.textContent = '0% Completed';
      resetBtn.style.display = 'none';
      updateBackground();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGround();
      player.y = groundY - player.height;
      drawPlayer();
    });
  });

  // Init
  loadProgress();
  updateLevelButtons();
  updateBackground();
  drawGround();
  player.y = groundY - player.height;
  messageEl.textContent = "Tap or click to jump. Avoid the spikes!";
})();
</script>

</body>
</html>
