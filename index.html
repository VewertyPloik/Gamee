<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Block Dash - Play & Level Editor</title>
<style>
  body {
    margin: 0; 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    background: #222;
    color: white;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    display: flex;
    justify-content: center;
    background: #111;
    padding: 10px 0;
    border-bottom: 2px solid #444;
  }
  button.tab-btn {
    background: #333;
    border: none;
    color: white;
    padding: 10px 25px;
    margin: 0 5px;
    font-size: 1rem;
    border-radius: 5px 5px 0 0;
    cursor: pointer;
    transition: background 0.3s;
  }
  button.tab-btn.active {
    background: #4e54c8;
  }
  main {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 15px;
    background: #1e1e1e;
  }
  #level-select, #editor-level-list {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 15px;
  }
  .level-button, .editor-level-button {
    background: #555;
    border-radius: 8px;
    padding: 8px 14px;
    font-weight: bold;
    font-size: 1rem;
    cursor: pointer;
    color: white;
    border: 2px solid transparent;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .level-button.locked, .editor-level-button.locked {
    background: #444;
    color: #888;
    cursor: default;
  }
  .level-button.selected, .editor-level-button.selected {
    border-color: #fff;
    background: #777;
  }
  #play-button, #save-level-btn, #new-level-btn {
    margin-top: 10px;
    background: #4e54c8;
    border: none;
    border-radius: 8px;
    color: white;
    padding: 10px 22px;
    font-size: 1.1rem;
    cursor: pointer;
    transition: background 0.3s;
  }
  #play-button:hover, #save-level-btn:hover, #new-level-btn:hover {
    background: #3b3fc1;
  }
  #progress {
    margin-top: 6px;
    font-family: Consolas, monospace;
    font-size: 18px;
  }
  #game-container {
    position: relative;
    width: 600px;
    height: 300px;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 0 30px #0009 inset;
    background: #222;
  }
  canvas {
    display: block;
    border-radius: 12px;
    background: linear-gradient(to bottom, #6dd5fa, #2980b9);
    cursor: pointer;
  }

  /* Editor styles */
  #editor {
    width: 620px;
    max-width: 100%;
    background: #333;
    padding: 10px 12px;
    border-radius: 12px;
    box-sizing: border-box;
  }
  #editor-label {
    margin-bottom: 6px;
    font-size: 1.2rem;
  }
  #level-name-input {
    width: 100%;
    font-size: 1.1rem;
    padding: 6px 10px;
    border-radius: 6px;
    border: none;
    margin-bottom: 10px;
    box-sizing: border-box;
  }
  #spike-types {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
  }
  .spike-type-btn {
    background: #4e54c8;
    border-radius: 8px;
    padding: 8px 12px;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    transition: background 0.3s;
  }
  .spike-type-btn.selected {
    background: #3b3fc1;
  }
  #timeline {
    width: 100%;
    height: 60px;
    background: #222;
    border-radius: 8px;
    position: relative;
    user-select: none;
    overflow-x: scroll;
    white-space: nowrap;
    box-sizing: border-box;
    padding: 5px 0;
  }
  .timeline-segment {
    display: inline-block;
    width: 25px;
    height: 60px;
    margin: 0 1px;
    background: #555;
    border-radius: 4px;
    position: relative;
    cursor: pointer;
  }
  .timeline-segment.selected {
    background: #4e54c8;
  }
  .timeline-spikes {
    position: absolute;
    bottom: 4px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 3px;
  }
  .timeline-spike {
    width: 18px;
    height: 18px;
    clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
    background: white;
  }

  /* Scrollbar for timeline */
  #timeline::-webkit-scrollbar {
    height: 8px;
  }
  #timeline::-webkit-scrollbar-thumb {
    background: #666;
    border-radius: 4px;
  }

  /* Checkbox for completed */
  .completed-check {
    color: #0f0;
    font-weight: bold;
  }

  /* Responsive tweaks */
  @media (max-width: 650px) {
    #game-container, #editor {
      width: 100%;
    }
    canvas {
      width: 100%;
      height: auto;
    }
  }
</style>
</head>
<body>

<header>
  <button id="tab-play" class="tab-btn active">Play Levels</button>
  <button id="tab-editor" class="tab-btn">Level Editor</button>
</header>

<main>
  <!-- Play Tab -->
  <section id="play-tab">
    <div id="level-select"></div>
    <button id="play-button" disabled>Play</button>
    <div id="progress">Progress: 0%</div>
    <div id="game-container">
      <canvas id="game" width="600" height="300" tabindex="0" title="Click or tap to jump"></canvas>
    </div>
  </section>

  <!-- Editor Tab -->
  <section id="editor-tab" style="display:none;">
    <button id="new-level-btn">New Level</button>
    <div id="editor-level-list" style="margin: 10px 0;"></div>
    <div id="editor" style="display:none;">
      <label id="editor-label" for="level-name-input">Level Name:</label>
      <input type="text" id="level-name-input" placeholder="Enter level name" />
      <div id="spike-types">
        <div class="spike-type-btn" data-count="1">1 Spike</div>
        <div class="spike-type-btn" data-count="2">2 Spikes</div>
        <div class="spike-type-btn" data-count="3">3 Spikes</div>
        <div class="spike-type-btn" data-count="4">4 Spikes</div>
      </div>
      <div id="timeline"></div>
      <button id="save-level-btn" disabled>Save Level</button>
    </div>
  </section>
</main>

<script>
(() => {
  const tabPlay = document.getElementById('tab-play');
  const tabEditor = document.getElementById('tab-editor');
  const playTab = document.getElementById('play-tab');
  const editorTab = document.getElementById('editor-tab');
  const levelSelectDiv = document.getElementById('level-select');
  const playBtn = document.getElementById('play-button');
  const progressDisplay = document.getElementById('progress');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Editor DOM
  const newLevelBtn = document.getElementById('new-level-btn');
  const editorLevelList = document.getElementById('editor-level-list');
  const editorDiv = document.getElementById('editor');
  const levelNameInput = document.getElementById('level-name-input');
  const spikeTypeButtons = Array.from(document.querySelectorAll('.spike-type-btn'));
  const timelineDiv = document.getElementById('timeline');
  const saveLevelBtn = document.getElementById('save-level-btn');

  const width = canvas.width;
  const height = canvas.height;

  const levelDuration = 31000;

  const spikeWidth = 25;
  const spikeHeight = 25;

  let gameRunning = false;
  let gameOver = false;
  let startTime = 0;

  const player = {
    x: 80,
    y: height - 40 - 30,
    width: 30,
    height: 30,
    color: '#ffd700',
    vy: 0,
    gravity: 0.8,
    jumpPower: -14,
    onGround: true,
    baseY: height - 40 - 30,
  };

  const spikeSpeed = 6;
  const timelineLengthPx = spikeSpeed * Math.floor(levelDuration / 16.67);
  const timelineSegments = Math.floor(timelineLengthPx / 25);

  let timelineSegmentsData = new Array(timelineSegments).fill(0);
  let spikes = [];

  let levels = [];
  let beatenLevels = new Set();

  let currentLevelIndex = 0;
  let selectedLevel = null;

  let editorSelectedLevelIndex = -1;
  let selectedSpikeCount = 1;

  function switchTab(tab) {
    if (gameRunning) {
      alert('Finish current game before switching tabs!');
      return;
    }
    if (tab === 'play') {
      playTab.style.display = 'block';
      editorTab.style.display = 'none';
      tabPlay.classList.add('active');
      tabEditor.classList.remove('active');
    } else {
      playTab.style.display = 'none';
      editorTab.style.display = 'block';
      tabPlay.classList.remove('active');
      tabEditor.classList.add('active');
      editorDiv.style.display = editorSelectedLevelIndex === -1 ? 'block' : 'block';
    }
  }
  tabPlay.addEventListener('click', () => switchTab('play'));
  tabEditor.addEventListener('click', () => switchTab('editor'));

  function saveLevels() {
    localStorage.setItem('blockDashLevels', JSON.stringify(levels));
  }
  function loadLevels() {
    const stored = localStorage.getItem('blockDashLevels');
    if (stored) {
      levels = JSON.parse(stored);
      levels.forEach(lvl => {
        if (typeof lvl.custom === 'undefined') lvl.custom = false;
      });
    } else {
      levels = [
        {
          id: 'numeroUno',
          name: 'Numero Uno',
          spikes: [
            { pos: 500, count: 1 },
            { pos: 1000, count: 2 },
            { pos: 1700, count: 1 },
            { pos: 2200, count: 2 }
          ],
          custom: false,
        },
        {
          id: 'dive',
          name: 'Dive',
          spikes: [
            { pos: 400, count: 1 },
            { pos: 900, count: 3 },
            { pos: 1400, count: 2 },
            { pos: 2000, count: 3 }
          ],
          custom: false,
        },
        {
          id: 'blood',
          name: 'Blood',
          spikes: [
            { pos: 300, count: 4 },
            { pos: 900, count: 3 },
            { pos: 1300, count: 2 },
            { pos: 1900, count: 4 }
          ],
          custom: false,
        }
      ];
      saveLevels();
    }
  }
  function saveBeaten() {
    localStorage.setItem('blockDashBeaten', JSON.stringify(Array.from(beatenLevels)));
  }
  function loadBeaten() {
    const stored = localStorage.getItem('blockDashBeaten');
    if (stored) {
      beatenLevels = new Set(JSON.parse(stored));
    } else {
      beatenLevels = new Set();
    }
  }

  function renderLevelSelect() {
    levelSelectDiv.innerHTML = '';
    levels.forEach((level, i) => {
      const btn = document.createElement('button');
      btn.classList.add('level-button');
      btn.textContent = level.name;
      if (beatenLevels.has(level.id)) {
        const check = document.createElement('span');
        check.textContent = '✅';
        check.classList.add('completed-check');
        btn.appendChild(check);
      }
      if (i === currentLevelIndex) {
        btn.classList.add('selected');
      }
      // Lock built-in levels except first or if previous built-in beaten
      if (!level.custom) {
        if (i > 0 && !beatenLevels.has(levels[i - 1].id)) {
          btn.disabled = true;
          btn.classList.add('locked');
        }
      }
      // Custom levels never locked
      btn.addEventListener('click', () => {
        if (gameRunning) {
          alert('Finish current game before switching levels!');
          return;
        }
        if (btn.disabled) return;
        currentLevelIndex = i;
        selectedLevel = levels[i];
        renderLevelSelect();
        playBtn.disabled = false;
        progressDisplay.textContent = 'Progress: 0%';
      });
      levelSelectDiv.appendChild(btn);
    });
    // Select first if none selected
    if (!selectedLevel && levels.length > 0) {
      currentLevelIndex = 0;
      selectedLevel = levels[0];
      playBtn.disabled = false;
    }
  }

  function renderEditorLevelList() {
    editorLevelList.innerHTML = '';
    levels.forEach((level, i) => {
      const btn = document.createElement('button');
      btn.classList.add('editor-level-button');
      btn.textContent = level.name;
      if (beatenLevels.has(level.id)) {
        btn.textContent += ' ✅';
      }
      if (i === editorSelectedLevelIndex) btn.classList.add('selected');
      btn.disabled = !level.custom;
      btn.addEventListener('click', () => {
        if (!level.custom) {
          alert('Built-in levels cannot be edited.');
          return;
        }
        editorSelectedLevelIndex = i;
        loadLevelInEditor(level);
        renderEditorLevelList();
        editorDiv.style.display = 'block';
      });
      editorLevelList.appendChild(btn);
    });
  }

  function createNewLevel() {
    editorSelectedLevelIndex = -1;
    timelineSegmentsData = new Array(timelineSegments).fill(0);
    levelNameInput.value = '';
    renderTimeline();
    editorDiv.style.display = 'block';
    saveLevelBtn.disabled = false;
  }

  function loadLevelInEditor(level) {
    timelineSegmentsData = new Array(timelineSegments).fill(0);
    level.spikes.forEach(sp => {
      let startIndex = Math.floor(sp.pos / 25);
      for (let i = 0; i < sp.count; i++) {
        if (startIndex + i < timelineSegments) {
          timelineSegmentsData[startIndex + i] = sp.count;
        }
      }
    });
    levelNameInput.value = level.name;
    saveLevelBtn.disabled = false;
    renderTimeline();
  }

  spikeTypeButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      spikeTypeButtons.forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      selectedSpikeCount = Number(btn.dataset.count);
    });
  });
  spikeTypeButtons[0].classList.add('selected');

  function saveLevelFromEditor() {
    const name = levelNameInput.value.trim();
    if (!name) {
      alert('Please enter a level name!');
      return;
    }
    for (let i = timelineSegments - 40; i < timelineSegments; i++) {
      if (timelineSegmentsData[i] > 0) {
        alert('Spikes are not allowed in the last 1 second of the level.');
        return;
      }
    }
    const spikesData = [];
    for (let i = 0; i < timelineSegmentsData.length; i++) {
      const count = timelineSegmentsData[i];
      if (count > 0) {
        spikesData.push({ pos: i * 25, count });
      }
    }
    if (spikesData.length === 0) {
      alert('Add some spikes before saving!');
      return;
    }
    if (editorSelectedLevelIndex === -1) {
      const newLevel = {
        id: Date.now().toString(),
        name,
        spikes: spikesData,
        custom: true,
      };
      levels.push(newLevel);
      editorSelectedLevelIndex = levels.length - 1;
    } else {
      if (!levels[editorSelectedLevelIndex].custom) {
        alert('Cannot edit built-in levels!');
        return;
      }
      levels[editorSelectedLevelIndex].name = name;
      levels[editorSelectedLevelIndex].spikes = spikesData;
    }
    saveLevels();
    renderEditorLevelList();
    renderLevelSelect();
    alert('Level saved!');
  }

  function renderTimeline() {
    timelineDiv.innerHTML = '';
    for (let i = 0; i < timelineSegments; i++) {
      const seg = document.createElement('div');
      seg.classList.add('timeline-segment');
      if (timelineSegmentsData[i] > 0) seg.classList.add('selected');
      seg.dataset.index = i;

      if (timelineSegmentsData[i] > 0) {
        const spikeContainer = document.createElement('div');
        spikeContainer.classList.add('timeline-spikes');
        for (let s = 0; s < timelineSegmentsData[i]; s++) {
          const spike = document.createElement('div');
          spike.classList.add('timeline-spike');
          spikeContainer.appendChild(spike);
        }
        seg.appendChild(spikeContainer);
      }

      seg.addEventListener('click', () => {
        if (i >= timelineSegments - 40) {
          alert('Cannot place spikes in the last 1 second of the level!');
          return;
        }
        if (timelineSegmentsData[i] === selectedSpikeCount) {
          timelineSegmentsData[i] = 0;
        } else {
          timelineSegmentsData[i] = selectedSpikeCount;
        }
        renderTimeline();
      });

      timelineDiv.appendChild(seg);
    }
  }

  function loadSpikesFromLevel(level) {
    spikes = [];
    let levelSpeed = spikeSpeed + currentLevelIndex * 2;

    level.spikes.forEach(sp => {
      for (let i = 0; i < sp.count; i++) {
        spikes.push({
          x: 600 + sp.pos + i * (spikeWidth + 2),
          y: height - 40 - spikeHeight,
          width: spikeWidth,
          height: spikeHeight,
        });
      }
    });
    return levelSpeed;
  }

  function drawSpike(x, y, w, h) {
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.moveTo(x, y + h);
    ctx.lineTo(x + w / 2, y);
    ctx.lineTo(x + w, y + h);
    ctx.closePath();
    ctx.fill();
  }

  function pointInTriangle(px, py, ax, ay, bx, by, cx, cy) {
    const v0x = cx - ax;
    const v0y = cy - ay;
    const v1x = bx - ax;
    const v1y = by - ay;
    const v2x = px - ax;
    const v2y = py - ay;

    const dot00 = v0x * v0x + v0y * v0y;
    const dot01 = v0x * v1x + v0y * v1y;
    const dot02 = v0x * v2x + v0y * v2y;
    const dot11 = v1x * v1x + v1y * v1y;
    const dot12 = v1x * v2x + v1y * v2y;

    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) return false;

    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    return (u >= 0) && (v >= 0) && (u + v < 1);
  }

  function checkSpikeCollision(spike) {
    const ax = spike.x;
    const ay = spike.y + spike.height;
    const bx = spike.x + spike.width / 2;
    const by = spike.y;
    const cx = spike.x + spike.width;
    const cy = spike.y + spike.height;

    const corners = [
      { x: player.x, y: player.y },
      { x: player.x + player.width, y: player.y },
      { x: player.x, y: player.y + player.height },
      { x: player.x + player.width, y: player.y + player.height }
    ];

    for (const corner of corners) {
      if (pointInTriangle(corner.x, corner.y, ax, ay, bx, by, cx, cy)) {
        return true;
      }
    }
    if (bx >= player.x && bx <= player.x + player.width &&
        by >= player.y && by <= player.y + player.height) {
      return true;
    }
    return false;
  }

  function resetGame() {
    if (!selectedLevel) return;
    gameOver = false;
    gameRunning = true;
    startTime = performance.now();
    player.y = player.baseY;
    player.vy = 0;
    player.onGround = true;

    spikeSpeedCurrent = loadSpikesFromLevel(selectedLevel);
    playBtn.disabled = true;
    progressDisplay.textContent = 'Progress: 0%';
  }

  function gameLoop(timestamp) {
    if (!gameRunning) return;
    ctx.clearRect(0, 0, width, height);

    const bgColors = [
      ['#6dd5fa', '#2980b9'],
      ['#56ab2f', '#a8e063'],
      ['#cb2d3e', '#ef473a'],
    ];
    let bg = bgColors[currentLevelIndex] || bgColors[0];
    let gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, bg[0]);
    gradient.addColorStop(1, bg[1]);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, height - 40, width, 40);

    player.vy += player.gravity;
    player.y += player.vy;
    if (player.y > player.baseY) {
      player.y = player.baseY;
      player.vy = 0;
      player.onGround = true;
    }

    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);

    let collision = false;
    for (const spike of spikes) {
      spike.x -= spikeSpeedCurrent;
      drawSpike(spike.x, spike.y, spike.width, spike.height);
      if (checkSpikeCollision(spike)) collision = true;
    }

    const elapsed = timestamp - startTime;
    const progressPercent = Math.min(100, (elapsed / levelDuration) * 100);
    progressDisplay.textContent = `Progress: ${progressPercent.toFixed(1)}%`;

    if (collision) {
      gameOver = true;
    }

    if (gameOver) {
      gameRunning = false;
      playBtn.disabled = false;

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = 'white';
      ctx.font = '36px Arial Black, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', width / 2, height / 2 - 20);
      ctx.font = '20px Arial, sans-serif';
      ctx.fillText('Click Play to try again', width / 2, height / 2 + 20);

      return;
    }

    if (elapsed >= levelDuration) {
      gameRunning = false;
      playBtn.disabled = false;

      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = 'white';
      ctx.font = '36px Arial Black, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Level Complete!', width / 2, height / 2 - 20);
      ctx.font = '20px Arial, sans-serif';
      ctx.fillText('Click Play to play again', width / 2, height / 2 + 20);

      beatenLevels.add(selectedLevel.id);
      saveBeaten();
      renderLevelSelect();
      renderEditorLevelList();

      return;
    }

    requestAnimationFrame(gameLoop);
  }

  function jump() {
    if (!gameRunning) return;
    if (player.onGround) {
      player.vy = player.jumpPower;
      player.onGround = false;
    }
  }

  canvas.addEventListener('mousedown', jump);
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    jump();
  }, { passive: false });
  window.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      jump();
    }
  });

  playBtn.addEventListener('click', () => {
    if (!selectedLevel) return;
    resetGame();
    requestAnimationFrame(gameLoop);
  });

  newLevelBtn.addEventListener('click', () => {
    createNewLevel();
  });
  saveLevelBtn.addEventListener('click', () => {
    saveLevelFromEditor();
  });

  loadLevels();
  loadBeaten();

  if (levels.length > 0) {
    selectedLevel = levels[0];
    currentLevelIndex = 0;
  }
  renderLevelSelect();
  renderEditorLevelList();

  editorSelectedLevelIndex = -1;
  editorDiv.style.display = 'none';

})();
</script>

</body>
</html>
