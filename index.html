<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Mini Geometry Dash - Numero Uno</title>
<style>
  body {
    margin: 0; 
    background: linear-gradient(#4a90e2, #50e3c2);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  #game, #editor {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    background: transparent;
  }
  canvas {
    background: #222;
    border-radius: 10px;
    max-width: 100vw;
    max-height: 60vh;
    touch-action: manipulation;
  }
  #ui {
    position: fixed;
    bottom: 0;
    width: 100%;
    background: #222a;
    color: white;
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 12px;
    font-size: 14px;
  }
  button, input[type=number], input[type=range] {
    padding: 6px 10px;
    border-radius: 6px;
    border: none;
    outline: none;
    font-size: 14px;
    user-select: none;
    cursor: pointer;
  }
  button {
    background: #50e3c2;
    color: #222;
    font-weight: bold;
  }
  input[type=range] {
    -webkit-appearance: none;
    background: #555;
    height: 6px;
    border-radius: 3px;
    cursor: pointer;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: #50e3c2;
    border-radius: 50%;
    cursor: pointer;
  }
  label {
    display: flex;
    align-items: center;
    gap: 6px;
    user-select: none;
  }
  #message {
    position: fixed;
    top: 12px;
    width: 100%;
    text-align: center;
    font-weight: bold;
    font-size: 18px;
    color: #fff;
    text-shadow: 1px 1px 4px #000a;
  }
</style>
</head>
<body>

<div id="message"></div>

<div id="game">
  <canvas id="gameCanvas" width="600" height="150"></canvas>
</div>

<div id="ui">
  <button id="playBtn">Play Numero Uno</button>
  <button id="editBtn">Level Editor</button>
  <button id="resetBtn" style="display:none;">Reset Level</button>
  
  <div id="editorUI" style="display:none; width: 100%; max-width: 600px;">
    <label>Speed: <input type="range" id="speedRange" min="1" max="10" step="0.1" value="3"></label>
    <label>Length (seconds): <input type="number" id="lengthInput" min="10" max="60" step="1" value="30" style="width:60px;"></label>
    <label>Spikes Count: <input type="number" id="spikeCount" min="0" max="30" step="1" value="15" style="width:60px;"></label>
    <button id="generateLevelBtn">Generate Level</button>
    <button id="saveLevelBtn">Save & Play</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Game state
  let gameRunning = false;
  let gameOver = false;
  let win = false;

  // Player
  const player = {
    x: 50,
    y: 0,
    width: 30,
    height: 30,
    yVelocity: 0,
    gravity: 0.8,
    jumpStrength: -14,
    grounded: false,
  };

  // Level data
  let level = {
    speed: 3,    // px per frame multiplier
    lengthSec: 30,
    spikes: [],
  };

  // Editor state
  let editing = false;

  // Calculated
  const spikeWidth = 20;
  const spikeHeight = 40;
  const groundY = canvas.height - 40;

  // Timing
  let frames = 0;
  let maxFrames = 0; // depends on length and speed

  // Messages
  const messageEl = document.getElementById('message');

  // UI elements
  const playBtn = document.getElementById('playBtn');
  const editBtn = document.getElementById('editBtn');
  const resetBtn = document.getElementById('resetBtn');
  const editorUI = document.getElementById('editorUI');
  const speedRange = document.getElementById('speedRange');
  const lengthInput = document.getElementById('lengthInput');
  const spikeCountInput = document.getElementById('spikeCount');
  const generateLevelBtn = document.getElementById('generateLevelBtn');
  const saveLevelBtn = document.getElementById('saveLevelBtn');

  // Initialize default level: Numero Uno
  function createDefaultLevel() {
    level.speed = 3;
    level.lengthSec = 30;
    level.spikes = [];
    // Create spikes spaced evenly after 3 seconds to 28 seconds:
    // spikes every 1.5 seconds roughly
    const spikesCount = 15;
    for (let i = 0; i < spikesCount; i++) {
      let timeSec = 3 + i * 1.5;
      let posX = timeToX(timeSec);
      level.spikes.push(posX);
    }
  }

  // Convert time in seconds to x position on canvas
  function timeToX(timeSec) {
    // The level length in px is speed * maxFrames
    // maxFrames = lengthSec * 60 (assuming 60fps)
    return timeSec * level.speed * 60;
  }

  // Convert x position to time in seconds (inverse)
  function xToTime(x) {
    return x / (level.speed * 60);
  }

  // Reset game state to start playing
  function resetGame() {
    gameRunning = true;
    gameOver = false;
    win = false;
    frames = 0;
    player.y = groundY - player.height;
    player.yVelocity = 0;
    player.grounded = true;
    maxFrames = Math.floor(level.lengthSec * 60);
    messageEl.textContent = '';
    resetBtn.style.display = 'inline-block';
  }

  // Draw player
  function drawPlayer() {
    ctx.fillStyle = '#50e3c2';
    ctx.fillRect(player.x, player.y, player.width, player.height);
  }

  // Draw ground
  function drawGround() {
    ctx.fillStyle = '#333';
    ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
  }

  // Draw spikes
  function drawSpikes(offsetX) {
    ctx.fillStyle = '#e94e4e';
    level.spikes.forEach(spikeX => {
      let screenX = spikeX - offsetX;
      if (screenX + spikeWidth > 0 && screenX < canvas.width) {
        ctx.beginPath();
        ctx.moveTo(screenX, groundY);
        ctx.lineTo(screenX + spikeWidth/2, groundY - spikeHeight);
        ctx.lineTo(screenX + spikeWidth, groundY);
        ctx.closePath();
        ctx.fill();
      }
    });
  }

  // Check collisions with spikes
  function checkCollision(offsetX) {
    for (let spikeX of level.spikes) {
      let spikeScreenX = spikeX - offsetX;
      if (
        spikeScreenX < player.x + player.width &&
        spikeScreenX + spikeWidth > player.x &&
        player.y + player.height > groundY - spikeHeight
      ) {
        return true;
      }
    }
    return false;
  }

  // Game loop
  function gameLoop() {
    if (!gameRunning) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Calculate offset to simulate player moving forward
    // Player x is fixed, level moves left by speed
    let offsetX = frames * level.speed;

    // Update player physics
    player.yVelocity += player.gravity;
    player.y += player.yVelocity;

    // Ground collision
    if (player.y + player.height >= groundY) {
      player.y = groundY - player.height;
      player.yVelocity = 0;
      player.grounded = true;
    } else {
      player.grounded = false;
    }

    // Draw
    drawGround();
    drawSpikes(offsetX);
    drawPlayer();

    // Check collision
    if (checkCollision(offsetX)) {
      gameOver = true;
      gameRunning = false;
      messageEl.textContent = "ðŸ’¥ You hit a spike! Tap Play to try again.";
      resetBtn.style.display = 'none';
      return;
    }

    frames++;

    // Check win condition
    if (frames > maxFrames) {
      gameRunning = false;
      win = true;
      messageEl.textContent = "ðŸŽ‰ Level Complete! Tap Play to replay.";
      resetBtn.style.display = 'none';
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  // Handle jump input
  function jump() {
    if (gameRunning && player.grounded) {
      player.yVelocity = player.jumpStrength;
      player.grounded = false;
    }
  }

  // Mobile and desktop input
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    jump();
  });

  canvas.addEventListener('mousedown', e => {
    e.preventDefault();
    jump();
  });

  // UI button handlers
  playBtn.addEventListener('click', () => {
    editing = false;
    editorUI.style.display = 'none';
    resetBtn.style.display = 'inline-block';
    createDefaultLevel();
    resetGame();
    gameLoop();
  });

  editBtn.addEventListener('click', () => {
    editing = true;
    messageEl.textContent = '';
    resetBtn.style.display = 'none';
    editorUI.style.display = 'flex';
    gameRunning = false;
    gameOver = false;
    win = false;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGround();
    // Load editor defaults
    speedRange.value = 3;
    lengthInput.value = 30;
    spikeCountInput.value = 15;
    drawEditorSpikes([]);
  });

  resetBtn.addEventListener('click', () => {
    if (!editing) {
      resetGame();
      gameLoop();
      messageEl.textContent = '';
    }
  });

  // Generate random spikes for editor
  function generateSpikes(count, lengthSec, speed) {
    // Spread spikes evenly but randomly jittered over level length
    const spikes = [];
    for (let i = 0; i < count; i++) {
      // Random time between 3 seconds and lengthSec - 2
      const time = 3 + Math.random() * (lengthSec - 5);
      spikes.push(timeToX(time));
    }
    // Sort ascending for ease
    spikes.sort((a, b) => a - b);
    return spikes;
  }

  // Draw editor spikes as preview
  function drawEditorSpikes(spikes) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGround();
    spikes.forEach(spikeX => {
      if (spikeX + spikeWidth > 0 && spikeX < canvas.width) {
        ctx.fillStyle = '#e94e4e';
        ctx.beginPath();
        ctx.moveTo(spikeX, groundY);
        ctx.lineTo(spikeX + spikeWidth/2, groundY - spikeHeight);
        ctx.lineTo(spikeX + spikeWidth, groundY);
        ctx.closePath();
        ctx.fill();
      }
    });
    // Draw player stationary for reference
    ctx.fillStyle = '#50e3c2';
    ctx.fillRect(player.x, groundY - player.height, player.width, player.height);
  }

  // Generate level preview button
  generateLevelBtn.addEventListener('click', () => {
    const speed = parseFloat(speedRange.value);
    const lengthSec = parseInt(lengthInput.value);
    const spikeCount = parseInt(spikeCountInput.value);

    if (lengthSec < 10 || lengthSec > 60) {
      alert("Length must be between 10 and 60 seconds.");
      return;
    }
    if (speed < 1 || speed > 10) {
      alert("Speed must be between 1 and 10.");
      return;
    }
    if (spikeCount < 0 || spikeCount > 30) {
      alert("Spike count must be between 0 and 30.");
      return;
    }

    const spikes = generateSpikes(spikeCount, lengthSec, speed);
    drawEditorSpikes(spikes);
  });

  // Save level and play
  saveLevelBtn.addEventListener('click', () => {
    const speed = parseFloat(speedRange.value);
    const lengthSec = parseInt(lengthInput.value);
    const spikeCount = parseInt(spikeCountInput.value);

    level.speed = speed;
    level.lengthSec = lengthSec;
    level.spikes = generateSpikes(spikeCount, lengthSec, speed);

    resetGame();
    editing = false;
    editorUI.style.display = 'none';
    gameLoop();
  });

  // Initialize with default level and show ready screen
  createDefaultLevel();
  resetGame();

  // Show initial instructions
  messageEl.textContent = "Tap or click the screen to jump. Avoid the spikes!";

})();
</script>

</body>
</html>
